// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CPSCHEMADEF_AOC_H_
#define FLATBUFFERS_GENERATED_CPSCHEMADEF_AOC_H_

#include "flatbuffers/flatbuffers.h"

namespace AOC {

struct Pos;

struct UnitQueue;

struct UnitTraining;

struct MarketCoefficients;

struct Damage;

struct ProjectileFire;

struct ConfigMessage;

struct GameMessage;

struct Tech;

struct PlayerInfo;

struct PlayerObjects;

struct CommonObjectInfo;

struct Building;

struct Unit;

struct MapObject;

enum Restriction {
  Restriction_All = 0,
  Restriction_InList = 1,
  Restriction_MIN = Restriction_All,
  Restriction_MAX = Restriction_InList
};

inline const Restriction (&EnumValuesRestriction())[2] {
  static const Restriction values[] = {
    Restriction_All,
    Restriction_InList
  };
  return values;
}

inline const char * const *EnumNamesRestriction() {
  static const char * const names[] = {
    "All",
    "InList",
    nullptr
  };
  return names;
}

inline const char *EnumNameRestriction(Restriction e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRestriction()[index];
}

enum ObjectState {
  ObjectState_Ready = 0,
  ObjectState_Founded = 1,
  ObjectState_Alive = 2,
  ObjectState_Dying = 3,
  ObjectState_Dead = 4,
  ObjectState_Unknown1 = 5,
  ObjectState_Unknown2 = 6,
  ObjectState_Doppleganger = 7,
  ObjectState_MIN = ObjectState_Ready,
  ObjectState_MAX = ObjectState_Doppleganger
};

inline const ObjectState (&EnumValuesObjectState())[8] {
  static const ObjectState values[] = {
    ObjectState_Ready,
    ObjectState_Founded,
    ObjectState_Alive,
    ObjectState_Dying,
    ObjectState_Dead,
    ObjectState_Unknown1,
    ObjectState_Unknown2,
    ObjectState_Doppleganger
  };
  return values;
}

inline const char * const *EnumNamesObjectState() {
  static const char * const names[] = {
    "Ready",
    "Founded",
    "Alive",
    "Dying",
    "Dead",
    "Unknown1",
    "Unknown2",
    "Doppleganger",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectState(ObjectState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObjectState()[index];
}

enum TechState {
  TechState_CantResearch = -1,
  TechState_CanResearchLater = 0,
  TechState_CanResearch = 1,
  TechState_Researching = 2,
  TechState_Researched = 3,
  TechState_MIN = TechState_CantResearch,
  TechState_MAX = TechState_Researched
};

inline const TechState (&EnumValuesTechState())[5] {
  static const TechState values[] = {
    TechState_CantResearch,
    TechState_CanResearchLater,
    TechState_CanResearch,
    TechState_Researching,
    TechState_Researched
  };
  return values;
}

inline const char * const *EnumNamesTechState() {
  static const char * const names[] = {
    "CantResearch",
    "CanResearchLater",
    "CanResearch",
    "Researching",
    "Researched",
    nullptr
  };
  return names;
}

inline const char *EnumNameTechState(TechState e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(TechState_CantResearch);
  return EnumNamesTechState()[index];
}

enum ActionState {
  ActionState_None = 0,
  ActionState_Done = 1,
  ActionState_Wait = 2,
  ActionState_Search = 3,
  ActionState_GoTo = 4,
  ActionState_Follow = 5,
  ActionState_Attack = 6,
  ActionState_GatherBuildAttack = 7,
  ActionState_Dropoff = 8,
  ActionState_Turn = 9,
  ActionState_Delay = 10,
  ActionState_Move = 11,
  ActionState_ChopTree = 12,
  ActionState_Failed = 13,
  ActionState_Invalidated = 14,
  ActionState_MoveNoSearch = 15,
  ActionState_MIN = ActionState_None,
  ActionState_MAX = ActionState_MoveNoSearch
};

inline const ActionState (&EnumValuesActionState())[16] {
  static const ActionState values[] = {
    ActionState_None,
    ActionState_Done,
    ActionState_Wait,
    ActionState_Search,
    ActionState_GoTo,
    ActionState_Follow,
    ActionState_Attack,
    ActionState_GatherBuildAttack,
    ActionState_Dropoff,
    ActionState_Turn,
    ActionState_Delay,
    ActionState_Move,
    ActionState_ChopTree,
    ActionState_Failed,
    ActionState_Invalidated,
    ActionState_MoveNoSearch
  };
  return values;
}

inline const char * const *EnumNamesActionState() {
  static const char * const names[] = {
    "None",
    "Done",
    "Wait",
    "Search",
    "GoTo",
    "Follow",
    "Attack",
    "GatherBuildAttack",
    "Dropoff",
    "Turn",
    "Delay",
    "Move",
    "ChopTree",
    "Failed",
    "Invalidated",
    "MoveNoSearch",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionState(ActionState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionState()[index];
}

enum PlayerState {
  PlayerState_Playing = 0,
  PlayerState_Winner = 1,
  PlayerState_Resigned = 2,
  PlayerState_Defeated = 3,
  PlayerState_MIN = PlayerState_Playing,
  PlayerState_MAX = PlayerState_Defeated
};

inline const PlayerState (&EnumValuesPlayerState())[4] {
  static const PlayerState values[] = {
    PlayerState_Playing,
    PlayerState_Winner,
    PlayerState_Resigned,
    PlayerState_Defeated
  };
  return values;
}

inline const char * const *EnumNamesPlayerState() {
  static const char * const names[] = {
    "Playing",
    "Winner",
    "Resigned",
    "Defeated",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlayerState(PlayerState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPlayerState()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pos FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Pos() {
    memset(this, 0, sizeof(Pos));
  }
  Pos(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Pos, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) UnitQueue FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t unitType_;
  int16_t unitCount_;

 public:
  UnitQueue() {
    memset(this, 0, sizeof(UnitQueue));
  }
  UnitQueue(int16_t _unitType, int16_t _unitCount)
      : unitType_(flatbuffers::EndianScalar(_unitType)),
        unitCount_(flatbuffers::EndianScalar(_unitCount)) {
  }
  int16_t unitType() const {
    return flatbuffers::EndianScalar(unitType_);
  }
  int16_t unitCount() const {
    return flatbuffers::EndianScalar(unitCount_);
  }
};
FLATBUFFERS_STRUCT_END(UnitQueue, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UnitTraining FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t unitType_;
  int16_t padding0__;
  float timer_;

 public:
  UnitTraining() {
    memset(this, 0, sizeof(UnitTraining));
  }
  UnitTraining(int16_t _unitType, float _timer)
      : unitType_(flatbuffers::EndianScalar(_unitType)),
        padding0__(0),
        timer_(flatbuffers::EndianScalar(_timer)) {
    (void)padding0__;
  }
  int16_t unitType() const {
    return flatbuffers::EndianScalar(unitType_);
  }
  float timer() const {
    return flatbuffers::EndianScalar(timer_);
  }
};
FLATBUFFERS_STRUCT_END(UnitTraining, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MarketCoefficients FLATBUFFERS_FINAL_CLASS {
 private:
  float wood_;
  float food_;
  float stone_;

 public:
  MarketCoefficients() {
    memset(this, 0, sizeof(MarketCoefficients));
  }
  MarketCoefficients(float _wood, float _food, float _stone)
      : wood_(flatbuffers::EndianScalar(_wood)),
        food_(flatbuffers::EndianScalar(_food)),
        stone_(flatbuffers::EndianScalar(_stone)) {
  }
  float wood() const {
    return flatbuffers::EndianScalar(wood_);
  }
  float food() const {
    return flatbuffers::EndianScalar(food_);
  }
  float stone() const {
    return flatbuffers::EndianScalar(stone_);
  }
};
FLATBUFFERS_STRUCT_END(MarketCoefficients, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Damage FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t gameTick_;
  int32_t attackerId_;
  uint32_t projectileId_;
  int32_t damagedId_;
  float damageDone_;

 public:
  Damage() {
    memset(this, 0, sizeof(Damage));
  }
  Damage(uint32_t _gameTick, int32_t _attackerId, uint32_t _projectileId, int32_t _damagedId, float _damageDone)
      : gameTick_(flatbuffers::EndianScalar(_gameTick)),
        attackerId_(flatbuffers::EndianScalar(_attackerId)),
        projectileId_(flatbuffers::EndianScalar(_projectileId)),
        damagedId_(flatbuffers::EndianScalar(_damagedId)),
        damageDone_(flatbuffers::EndianScalar(_damageDone)) {
  }
  uint32_t gameTick() const {
    return flatbuffers::EndianScalar(gameTick_);
  }
  int32_t attackerId() const {
    return flatbuffers::EndianScalar(attackerId_);
  }
  uint32_t projectileId() const {
    return flatbuffers::EndianScalar(projectileId_);
  }
  int32_t damagedId() const {
    return flatbuffers::EndianScalar(damagedId_);
  }
  float damageDone() const {
    return flatbuffers::EndianScalar(damageDone_);
  }
};
FLATBUFFERS_STRUCT_END(Damage, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ProjectileFire FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t gameTick_;
  uint32_t projectileId_;
  int32_t sourceId_;
  int32_t targetId_;
  int16_t type_;
  uint8_t isPrimary_;
  int8_t padding0__;

 public:
  ProjectileFire() {
    memset(this, 0, sizeof(ProjectileFire));
  }
  ProjectileFire(uint32_t _gameTick, uint32_t _projectileId, int32_t _sourceId, int32_t _targetId, int16_t _type, bool _isPrimary)
      : gameTick_(flatbuffers::EndianScalar(_gameTick)),
        projectileId_(flatbuffers::EndianScalar(_projectileId)),
        sourceId_(flatbuffers::EndianScalar(_sourceId)),
        targetId_(flatbuffers::EndianScalar(_targetId)),
        type_(flatbuffers::EndianScalar(_type)),
        isPrimary_(flatbuffers::EndianScalar(static_cast<uint8_t>(_isPrimary))),
        padding0__(0) {
    (void)padding0__;
  }
  uint32_t gameTick() const {
    return flatbuffers::EndianScalar(gameTick_);
  }
  uint32_t projectileId() const {
    return flatbuffers::EndianScalar(projectileId_);
  }
  int32_t sourceId() const {
    return flatbuffers::EndianScalar(sourceId_);
  }
  int32_t targetId() const {
    return flatbuffers::EndianScalar(targetId_);
  }
  int16_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  bool isPrimary() const {
    return flatbuffers::EndianScalar(isPrimary_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(ProjectileFire, 20);

struct ConfigMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TICKINTERVAL = 4,
    VT_MAPOBJECTTICKINTERVAL = 6,
    VT_UPDATECYCLES = 8,
    VT_PLAYERRESTRICTION = 10,
    VT_PLAYERRESTRICTV = 12,
    VT_OBJECTRESTRICTION = 14,
    VT_OBJECTRESTRICTV = 16
  };
  uint32_t tickInterval() const {
    return GetField<uint32_t>(VT_TICKINTERVAL, 500);
  }
  uint32_t mapObjectTickInterval() const {
    return GetField<uint32_t>(VT_MAPOBJECTTICKINTERVAL, 15000);
  }
  int32_t updateCycles() const {
    return GetField<int32_t>(VT_UPDATECYCLES, 1);
  }
  Restriction playerRestriction() const {
    return static_cast<Restriction>(GetField<int8_t>(VT_PLAYERRESTRICTION, 0));
  }
  const flatbuffers::Vector<int8_t> *playerRestrictV() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_PLAYERRESTRICTV);
  }
  Restriction objectRestriction() const {
    return static_cast<Restriction>(GetField<int8_t>(VT_OBJECTRESTRICTION, 0));
  }
  const flatbuffers::Vector<uint32_t> *objectRestrictV() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OBJECTRESTRICTV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TICKINTERVAL) &&
           VerifyField<uint32_t>(verifier, VT_MAPOBJECTTICKINTERVAL) &&
           VerifyField<int32_t>(verifier, VT_UPDATECYCLES) &&
           VerifyField<int8_t>(verifier, VT_PLAYERRESTRICTION) &&
           VerifyOffset(verifier, VT_PLAYERRESTRICTV) &&
           verifier.VerifyVector(playerRestrictV()) &&
           VerifyField<int8_t>(verifier, VT_OBJECTRESTRICTION) &&
           VerifyOffset(verifier, VT_OBJECTRESTRICTV) &&
           verifier.VerifyVector(objectRestrictV()) &&
           verifier.EndTable();
  }
};

struct ConfigMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tickInterval(uint32_t tickInterval) {
    fbb_.AddElement<uint32_t>(ConfigMessage::VT_TICKINTERVAL, tickInterval, 500);
  }
  void add_mapObjectTickInterval(uint32_t mapObjectTickInterval) {
    fbb_.AddElement<uint32_t>(ConfigMessage::VT_MAPOBJECTTICKINTERVAL, mapObjectTickInterval, 15000);
  }
  void add_updateCycles(int32_t updateCycles) {
    fbb_.AddElement<int32_t>(ConfigMessage::VT_UPDATECYCLES, updateCycles, 1);
  }
  void add_playerRestriction(Restriction playerRestriction) {
    fbb_.AddElement<int8_t>(ConfigMessage::VT_PLAYERRESTRICTION, static_cast<int8_t>(playerRestriction), 0);
  }
  void add_playerRestrictV(flatbuffers::Offset<flatbuffers::Vector<int8_t>> playerRestrictV) {
    fbb_.AddOffset(ConfigMessage::VT_PLAYERRESTRICTV, playerRestrictV);
  }
  void add_objectRestriction(Restriction objectRestriction) {
    fbb_.AddElement<int8_t>(ConfigMessage::VT_OBJECTRESTRICTION, static_cast<int8_t>(objectRestriction), 0);
  }
  void add_objectRestrictV(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> objectRestrictV) {
    fbb_.AddOffset(ConfigMessage::VT_OBJECTRESTRICTV, objectRestrictV);
  }
  explicit ConfigMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConfigMessageBuilder &operator=(const ConfigMessageBuilder &);
  flatbuffers::Offset<ConfigMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConfigMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConfigMessage> CreateConfigMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t tickInterval = 500,
    uint32_t mapObjectTickInterval = 15000,
    int32_t updateCycles = 1,
    Restriction playerRestriction = Restriction_All,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> playerRestrictV = 0,
    Restriction objectRestriction = Restriction_All,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> objectRestrictV = 0) {
  ConfigMessageBuilder builder_(_fbb);
  builder_.add_objectRestrictV(objectRestrictV);
  builder_.add_playerRestrictV(playerRestrictV);
  builder_.add_updateCycles(updateCycles);
  builder_.add_mapObjectTickInterval(mapObjectTickInterval);
  builder_.add_tickInterval(tickInterval);
  builder_.add_objectRestriction(objectRestriction);
  builder_.add_playerRestriction(playerRestriction);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConfigMessage> CreateConfigMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t tickInterval = 500,
    uint32_t mapObjectTickInterval = 15000,
    int32_t updateCycles = 1,
    Restriction playerRestriction = Restriction_All,
    const std::vector<int8_t> *playerRestrictV = nullptr,
    Restriction objectRestriction = Restriction_All,
    const std::vector<uint32_t> *objectRestrictV = nullptr) {
  return AOC::CreateConfigMessage(
      _fbb,
      tickInterval,
      mapObjectTickInterval,
      updateCycles,
      playerRestriction,
      playerRestrictV ? _fbb.CreateVector<int8_t>(*playerRestrictV) : 0,
      objectRestriction,
      objectRestrictV ? _fbb.CreateVector<uint32_t>(*objectRestrictV) : 0);
}

struct GameMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TICK = 4,
    VT_INSTANCEGAMENUMBER = 6,
    VT_FINISHED = 8,
    VT_MARKETCOEFFICIENTS = 10,
    VT_MAPNAME = 12,
    VT_PLAYERS = 14,
    VT_OBJECTS = 16,
    VT_PROJECTILESFIRED = 18,
    VT_DAMAGES = 20
  };
  uint32_t tick() const {
    return GetField<uint32_t>(VT_TICK, 0);
  }
  uint32_t instanceGameNumber() const {
    return GetField<uint32_t>(VT_INSTANCEGAMENUMBER, 0);
  }
  bool finished() const {
    return GetField<uint8_t>(VT_FINISHED, 0) != 0;
  }
  const MarketCoefficients *marketCoefficients() const {
    return GetStruct<const MarketCoefficients *>(VT_MARKETCOEFFICIENTS);
  }
  const flatbuffers::String *mapName() const {
    return GetPointer<const flatbuffers::String *>(VT_MAPNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>> *players() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>> *>(VT_PLAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PlayerObjects>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayerObjects>> *>(VT_OBJECTS);
  }
  const flatbuffers::Vector<const ProjectileFire *> *projectilesFired() const {
    return GetPointer<const flatbuffers::Vector<const ProjectileFire *> *>(VT_PROJECTILESFIRED);
  }
  const flatbuffers::Vector<const Damage *> *damages() const {
    return GetPointer<const flatbuffers::Vector<const Damage *> *>(VT_DAMAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TICK) &&
           VerifyField<uint32_t>(verifier, VT_INSTANCEGAMENUMBER) &&
           VerifyField<uint8_t>(verifier, VT_FINISHED) &&
           VerifyField<MarketCoefficients>(verifier, VT_MARKETCOEFFICIENTS) &&
           VerifyOffset(verifier, VT_MAPNAME) &&
           verifier.VerifyString(mapName()) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.VerifyVector(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyOffset(verifier, VT_PROJECTILESFIRED) &&
           verifier.VerifyVector(projectilesFired()) &&
           VerifyOffset(verifier, VT_DAMAGES) &&
           verifier.VerifyVector(damages()) &&
           verifier.EndTable();
  }
};

struct GameMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tick(uint32_t tick) {
    fbb_.AddElement<uint32_t>(GameMessage::VT_TICK, tick, 0);
  }
  void add_instanceGameNumber(uint32_t instanceGameNumber) {
    fbb_.AddElement<uint32_t>(GameMessage::VT_INSTANCEGAMENUMBER, instanceGameNumber, 0);
  }
  void add_finished(bool finished) {
    fbb_.AddElement<uint8_t>(GameMessage::VT_FINISHED, static_cast<uint8_t>(finished), 0);
  }
  void add_marketCoefficients(const MarketCoefficients *marketCoefficients) {
    fbb_.AddStruct(GameMessage::VT_MARKETCOEFFICIENTS, marketCoefficients);
  }
  void add_mapName(flatbuffers::Offset<flatbuffers::String> mapName) {
    fbb_.AddOffset(GameMessage::VT_MAPNAME, mapName);
  }
  void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>>> players) {
    fbb_.AddOffset(GameMessage::VT_PLAYERS, players);
  }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerObjects>>> objects) {
    fbb_.AddOffset(GameMessage::VT_OBJECTS, objects);
  }
  void add_projectilesFired(flatbuffers::Offset<flatbuffers::Vector<const ProjectileFire *>> projectilesFired) {
    fbb_.AddOffset(GameMessage::VT_PROJECTILESFIRED, projectilesFired);
  }
  void add_damages(flatbuffers::Offset<flatbuffers::Vector<const Damage *>> damages) {
    fbb_.AddOffset(GameMessage::VT_DAMAGES, damages);
  }
  explicit GameMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameMessageBuilder &operator=(const GameMessageBuilder &);
  flatbuffers::Offset<GameMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameMessage> CreateGameMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t tick = 0,
    uint32_t instanceGameNumber = 0,
    bool finished = false,
    const MarketCoefficients *marketCoefficients = 0,
    flatbuffers::Offset<flatbuffers::String> mapName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerInfo>>> players = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerObjects>>> objects = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ProjectileFire *>> projectilesFired = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Damage *>> damages = 0) {
  GameMessageBuilder builder_(_fbb);
  builder_.add_damages(damages);
  builder_.add_projectilesFired(projectilesFired);
  builder_.add_objects(objects);
  builder_.add_players(players);
  builder_.add_mapName(mapName);
  builder_.add_marketCoefficients(marketCoefficients);
  builder_.add_instanceGameNumber(instanceGameNumber);
  builder_.add_tick(tick);
  builder_.add_finished(finished);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameMessage> CreateGameMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t tick = 0,
    uint32_t instanceGameNumber = 0,
    bool finished = false,
    const MarketCoefficients *marketCoefficients = 0,
    const char *mapName = nullptr,
    const std::vector<flatbuffers::Offset<PlayerInfo>> *players = nullptr,
    const std::vector<flatbuffers::Offset<PlayerObjects>> *objects = nullptr,
    const std::vector<ProjectileFire> *projectilesFired = nullptr,
    const std::vector<Damage> *damages = nullptr) {
  return AOC::CreateGameMessage(
      _fbb,
      tick,
      instanceGameNumber,
      finished,
      marketCoefficients,
      mapName ? _fbb.CreateString(mapName) : 0,
      players ? _fbb.CreateVector<flatbuffers::Offset<PlayerInfo>>(*players) : 0,
      objects ? _fbb.CreateVector<flatbuffers::Offset<PlayerObjects>>(*objects) : 0,
      projectilesFired ? _fbb.CreateVectorOfStructs<ProjectileFire>(*projectilesFired) : 0,
      damages ? _fbb.CreateVectorOfStructs<Damage>(*damages) : 0);
}

struct Tech FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TECHIDINDEX = 4,
    VT_TECHIDGAME = 6,
    VT_TECHSTATE = 8,
    VT_TIMEPASSED = 10
  };
  int16_t techIdIndex() const {
    return GetField<int16_t>(VT_TECHIDINDEX, 0);
  }
  int16_t techIdGame() const {
    return GetField<int16_t>(VT_TECHIDGAME, 0);
  }
  TechState techState() const {
    return static_cast<TechState>(GetField<int16_t>(VT_TECHSTATE, 0));
  }
  float timePassed() const {
    return GetField<float>(VT_TIMEPASSED, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TECHIDINDEX) &&
           VerifyField<int16_t>(verifier, VT_TECHIDGAME) &&
           VerifyField<int16_t>(verifier, VT_TECHSTATE) &&
           VerifyField<float>(verifier, VT_TIMEPASSED) &&
           verifier.EndTable();
  }
};

struct TechBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_techIdIndex(int16_t techIdIndex) {
    fbb_.AddElement<int16_t>(Tech::VT_TECHIDINDEX, techIdIndex, 0);
  }
  void add_techIdGame(int16_t techIdGame) {
    fbb_.AddElement<int16_t>(Tech::VT_TECHIDGAME, techIdGame, 0);
  }
  void add_techState(TechState techState) {
    fbb_.AddElement<int16_t>(Tech::VT_TECHSTATE, static_cast<int16_t>(techState), 0);
  }
  void add_timePassed(float timePassed) {
    fbb_.AddElement<float>(Tech::VT_TIMEPASSED, timePassed, 0.0f);
  }
  explicit TechBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TechBuilder &operator=(const TechBuilder &);
  flatbuffers::Offset<Tech> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tech>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tech> CreateTech(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t techIdIndex = 0,
    int16_t techIdGame = 0,
    TechState techState = TechState_CanResearchLater,
    float timePassed = 0.0f) {
  TechBuilder builder_(_fbb);
  builder_.add_timePassed(timePassed);
  builder_.add_techState(techState);
  builder_.add_techIdGame(techIdGame);
  builder_.add_techIdIndex(techIdIndex);
  return builder_.Finish();
}

struct PlayerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYERID = 4,
    VT_PLAYERNAME = 6,
    VT_PLAYERSTATE = 8,
    VT_FOOD = 10,
    VT_WOOD = 12,
    VT_STONE = 14,
    VT_GOLD = 16,
    VT_HEADROOM = 18,
    VT_POPULATION = 20,
    VT_POPULATIONCAP = 22,
    VT_CIVILIANPOPULATION = 24,
    VT_MILITARYPOPULATION = 26,
    VT_PERCENTMAPEXPLORED = 28,
    VT_TECHS = 30,
    VT_MAINSELECTED = 32
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  const flatbuffers::String *playerName() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYERNAME);
  }
  PlayerState playerState() const {
    return static_cast<PlayerState>(GetField<int8_t>(VT_PLAYERSTATE, 0));
  }
  float food() const {
    return GetField<float>(VT_FOOD, 0.0f);
  }
  float wood() const {
    return GetField<float>(VT_WOOD, 0.0f);
  }
  float stone() const {
    return GetField<float>(VT_STONE, 0.0f);
  }
  float gold() const {
    return GetField<float>(VT_GOLD, 0.0f);
  }
  float headroom() const {
    return GetField<float>(VT_HEADROOM, 0.0f);
  }
  float population() const {
    return GetField<float>(VT_POPULATION, 0.0f);
  }
  float populationCap() const {
    return GetField<float>(VT_POPULATIONCAP, 0.0f);
  }
  float civilianPopulation() const {
    return GetField<float>(VT_CIVILIANPOPULATION, 0.0f);
  }
  float militaryPopulation() const {
    return GetField<float>(VT_MILITARYPOPULATION, 0.0f);
  }
  float percentMapExplored() const {
    return GetField<float>(VT_PERCENTMAPEXPLORED, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tech>> *techs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tech>> *>(VT_TECHS);
  }
  int32_t mainSelected() const {
    return GetField<int32_t>(VT_MAINSELECTED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID) &&
           VerifyOffset(verifier, VT_PLAYERNAME) &&
           verifier.VerifyString(playerName()) &&
           VerifyField<int8_t>(verifier, VT_PLAYERSTATE) &&
           VerifyField<float>(verifier, VT_FOOD) &&
           VerifyField<float>(verifier, VT_WOOD) &&
           VerifyField<float>(verifier, VT_STONE) &&
           VerifyField<float>(verifier, VT_GOLD) &&
           VerifyField<float>(verifier, VT_HEADROOM) &&
           VerifyField<float>(verifier, VT_POPULATION) &&
           VerifyField<float>(verifier, VT_POPULATIONCAP) &&
           VerifyField<float>(verifier, VT_CIVILIANPOPULATION) &&
           VerifyField<float>(verifier, VT_MILITARYPOPULATION) &&
           VerifyField<float>(verifier, VT_PERCENTMAPEXPLORED) &&
           VerifyOffset(verifier, VT_TECHS) &&
           verifier.VerifyVector(techs()) &&
           verifier.VerifyVectorOfTables(techs()) &&
           VerifyField<int32_t>(verifier, VT_MAINSELECTED) &&
           verifier.EndTable();
  }
};

struct PlayerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerInfo::VT_PLAYERID, playerId, 0);
  }
  void add_playerName(flatbuffers::Offset<flatbuffers::String> playerName) {
    fbb_.AddOffset(PlayerInfo::VT_PLAYERNAME, playerName);
  }
  void add_playerState(PlayerState playerState) {
    fbb_.AddElement<int8_t>(PlayerInfo::VT_PLAYERSTATE, static_cast<int8_t>(playerState), 0);
  }
  void add_food(float food) {
    fbb_.AddElement<float>(PlayerInfo::VT_FOOD, food, 0.0f);
  }
  void add_wood(float wood) {
    fbb_.AddElement<float>(PlayerInfo::VT_WOOD, wood, 0.0f);
  }
  void add_stone(float stone) {
    fbb_.AddElement<float>(PlayerInfo::VT_STONE, stone, 0.0f);
  }
  void add_gold(float gold) {
    fbb_.AddElement<float>(PlayerInfo::VT_GOLD, gold, 0.0f);
  }
  void add_headroom(float headroom) {
    fbb_.AddElement<float>(PlayerInfo::VT_HEADROOM, headroom, 0.0f);
  }
  void add_population(float population) {
    fbb_.AddElement<float>(PlayerInfo::VT_POPULATION, population, 0.0f);
  }
  void add_populationCap(float populationCap) {
    fbb_.AddElement<float>(PlayerInfo::VT_POPULATIONCAP, populationCap, 0.0f);
  }
  void add_civilianPopulation(float civilianPopulation) {
    fbb_.AddElement<float>(PlayerInfo::VT_CIVILIANPOPULATION, civilianPopulation, 0.0f);
  }
  void add_militaryPopulation(float militaryPopulation) {
    fbb_.AddElement<float>(PlayerInfo::VT_MILITARYPOPULATION, militaryPopulation, 0.0f);
  }
  void add_percentMapExplored(float percentMapExplored) {
    fbb_.AddElement<float>(PlayerInfo::VT_PERCENTMAPEXPLORED, percentMapExplored, 0.0f);
  }
  void add_techs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tech>>> techs) {
    fbb_.AddOffset(PlayerInfo::VT_TECHS, techs);
  }
  void add_mainSelected(int32_t mainSelected) {
    fbb_.AddElement<int32_t>(PlayerInfo::VT_MAINSELECTED, mainSelected, 0);
  }
  explicit PlayerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerInfoBuilder &operator=(const PlayerInfoBuilder &);
  flatbuffers::Offset<PlayerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerInfo> CreatePlayerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0,
    flatbuffers::Offset<flatbuffers::String> playerName = 0,
    PlayerState playerState = PlayerState_Playing,
    float food = 0.0f,
    float wood = 0.0f,
    float stone = 0.0f,
    float gold = 0.0f,
    float headroom = 0.0f,
    float population = 0.0f,
    float populationCap = 0.0f,
    float civilianPopulation = 0.0f,
    float militaryPopulation = 0.0f,
    float percentMapExplored = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tech>>> techs = 0,
    int32_t mainSelected = 0) {
  PlayerInfoBuilder builder_(_fbb);
  builder_.add_mainSelected(mainSelected);
  builder_.add_techs(techs);
  builder_.add_percentMapExplored(percentMapExplored);
  builder_.add_militaryPopulation(militaryPopulation);
  builder_.add_civilianPopulation(civilianPopulation);
  builder_.add_populationCap(populationCap);
  builder_.add_population(population);
  builder_.add_headroom(headroom);
  builder_.add_gold(gold);
  builder_.add_stone(stone);
  builder_.add_wood(wood);
  builder_.add_food(food);
  builder_.add_playerName(playerName);
  builder_.add_playerState(playerState);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerInfo> CreatePlayerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0,
    const char *playerName = nullptr,
    PlayerState playerState = PlayerState_Playing,
    float food = 0.0f,
    float wood = 0.0f,
    float stone = 0.0f,
    float gold = 0.0f,
    float headroom = 0.0f,
    float population = 0.0f,
    float populationCap = 0.0f,
    float civilianPopulation = 0.0f,
    float militaryPopulation = 0.0f,
    float percentMapExplored = 0.0f,
    const std::vector<flatbuffers::Offset<Tech>> *techs = nullptr,
    int32_t mainSelected = 0) {
  return AOC::CreatePlayerInfo(
      _fbb,
      playerId,
      playerName ? _fbb.CreateString(playerName) : 0,
      playerState,
      food,
      wood,
      stone,
      gold,
      headroom,
      population,
      populationCap,
      civilianPopulation,
      militaryPopulation,
      percentMapExplored,
      techs ? _fbb.CreateVector<flatbuffers::Offset<Tech>>(*techs) : 0,
      mainSelected);
}

struct PlayerObjects FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYERID = 4,
    VT_BUILDINGS = 6,
    VT_UNITS = 8,
    VT_MAPOBJECTS = 10
  };
  uint8_t playerId() const {
    return GetField<uint8_t>(VT_PLAYERID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Building>> *buildings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Building>> *>(VT_BUILDINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Unit>> *units() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MapObject>> *mapObjects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MapObject>> *>(VT_MAPOBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PLAYERID) &&
           VerifyOffset(verifier, VT_BUILDINGS) &&
           verifier.VerifyVector(buildings()) &&
           verifier.VerifyVectorOfTables(buildings()) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.VerifyVector(units()) &&
           verifier.VerifyVectorOfTables(units()) &&
           VerifyOffset(verifier, VT_MAPOBJECTS) &&
           verifier.VerifyVector(mapObjects()) &&
           verifier.VerifyVectorOfTables(mapObjects()) &&
           verifier.EndTable();
  }
};

struct PlayerObjectsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerId(uint8_t playerId) {
    fbb_.AddElement<uint8_t>(PlayerObjects::VT_PLAYERID, playerId, 0);
  }
  void add_buildings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Building>>> buildings) {
    fbb_.AddOffset(PlayerObjects::VT_BUILDINGS, buildings);
  }
  void add_units(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Unit>>> units) {
    fbb_.AddOffset(PlayerObjects::VT_UNITS, units);
  }
  void add_mapObjects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapObject>>> mapObjects) {
    fbb_.AddOffset(PlayerObjects::VT_MAPOBJECTS, mapObjects);
  }
  explicit PlayerObjectsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerObjectsBuilder &operator=(const PlayerObjectsBuilder &);
  flatbuffers::Offset<PlayerObjects> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerObjects>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerObjects> CreatePlayerObjects(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Building>>> buildings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Unit>>> units = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MapObject>>> mapObjects = 0) {
  PlayerObjectsBuilder builder_(_fbb);
  builder_.add_mapObjects(mapObjects);
  builder_.add_units(units);
  builder_.add_buildings(buildings);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerObjects> CreatePlayerObjectsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t playerId = 0,
    const std::vector<flatbuffers::Offset<Building>> *buildings = nullptr,
    const std::vector<flatbuffers::Offset<Unit>> *units = nullptr,
    const std::vector<flatbuffers::Offset<MapObject>> *mapObjects = nullptr) {
  return AOC::CreatePlayerObjects(
      _fbb,
      playerId,
      buildings ? _fbb.CreateVector<flatbuffers::Offset<Building>>(*buildings) : 0,
      units ? _fbb.CreateVector<flatbuffers::Offset<Unit>>(*units) : 0,
      mapObjects ? _fbb.CreateVector<flatbuffers::Offset<MapObject>>(*mapObjects) : 0);
}

struct CommonObjectInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECTID = 4,
    VT_OBJECTCLASS = 6,
    VT_OBJECTTYPE = 8,
    VT_OBJECTTYPENAME = 10,
    VT_OBJECTSTATE = 12,
    VT_POS = 14,
    VT_HP = 16,
    VT_MAXHP = 18,
    VT_RESOURCETYPE = 20,
    VT_RESOURCEAMOUNT = 22
  };
  int32_t objectId() const {
    return GetField<int32_t>(VT_OBJECTID, 0);
  }
  uint8_t objectClass() const {
    return GetField<uint8_t>(VT_OBJECTCLASS, 0);
  }
  int16_t objectType() const {
    return GetField<int16_t>(VT_OBJECTTYPE, 0);
  }
  const flatbuffers::String *objectTypeName() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECTTYPENAME);
  }
  ObjectState objectState() const {
    return static_cast<ObjectState>(GetField<int8_t>(VT_OBJECTSTATE, 0));
  }
  const Pos *pos() const {
    return GetStruct<const Pos *>(VT_POS);
  }
  float hp() const {
    return GetField<float>(VT_HP, 0.0f);
  }
  float maxHp() const {
    return GetField<float>(VT_MAXHP, 0.0f);
  }
  int16_t resourceType() const {
    return GetField<int16_t>(VT_RESOURCETYPE, 0);
  }
  float resourceAmount() const {
    return GetField<float>(VT_RESOURCEAMOUNT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID) &&
           VerifyField<uint8_t>(verifier, VT_OBJECTCLASS) &&
           VerifyField<int16_t>(verifier, VT_OBJECTTYPE) &&
           VerifyOffset(verifier, VT_OBJECTTYPENAME) &&
           verifier.VerifyString(objectTypeName()) &&
           VerifyField<int8_t>(verifier, VT_OBJECTSTATE) &&
           VerifyField<Pos>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_HP) &&
           VerifyField<float>(verifier, VT_MAXHP) &&
           VerifyField<int16_t>(verifier, VT_RESOURCETYPE) &&
           VerifyField<float>(verifier, VT_RESOURCEAMOUNT) &&
           verifier.EndTable();
  }
};

struct CommonObjectInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objectId(int32_t objectId) {
    fbb_.AddElement<int32_t>(CommonObjectInfo::VT_OBJECTID, objectId, 0);
  }
  void add_objectClass(uint8_t objectClass) {
    fbb_.AddElement<uint8_t>(CommonObjectInfo::VT_OBJECTCLASS, objectClass, 0);
  }
  void add_objectType(int16_t objectType) {
    fbb_.AddElement<int16_t>(CommonObjectInfo::VT_OBJECTTYPE, objectType, 0);
  }
  void add_objectTypeName(flatbuffers::Offset<flatbuffers::String> objectTypeName) {
    fbb_.AddOffset(CommonObjectInfo::VT_OBJECTTYPENAME, objectTypeName);
  }
  void add_objectState(ObjectState objectState) {
    fbb_.AddElement<int8_t>(CommonObjectInfo::VT_OBJECTSTATE, static_cast<int8_t>(objectState), 0);
  }
  void add_pos(const Pos *pos) {
    fbb_.AddStruct(CommonObjectInfo::VT_POS, pos);
  }
  void add_hp(float hp) {
    fbb_.AddElement<float>(CommonObjectInfo::VT_HP, hp, 0.0f);
  }
  void add_maxHp(float maxHp) {
    fbb_.AddElement<float>(CommonObjectInfo::VT_MAXHP, maxHp, 0.0f);
  }
  void add_resourceType(int16_t resourceType) {
    fbb_.AddElement<int16_t>(CommonObjectInfo::VT_RESOURCETYPE, resourceType, 0);
  }
  void add_resourceAmount(float resourceAmount) {
    fbb_.AddElement<float>(CommonObjectInfo::VT_RESOURCEAMOUNT, resourceAmount, 0.0f);
  }
  explicit CommonObjectInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommonObjectInfoBuilder &operator=(const CommonObjectInfoBuilder &);
  flatbuffers::Offset<CommonObjectInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommonObjectInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommonObjectInfo> CreateCommonObjectInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    uint8_t objectClass = 0,
    int16_t objectType = 0,
    flatbuffers::Offset<flatbuffers::String> objectTypeName = 0,
    ObjectState objectState = ObjectState_Ready,
    const Pos *pos = 0,
    float hp = 0.0f,
    float maxHp = 0.0f,
    int16_t resourceType = 0,
    float resourceAmount = 0.0f) {
  CommonObjectInfoBuilder builder_(_fbb);
  builder_.add_resourceAmount(resourceAmount);
  builder_.add_maxHp(maxHp);
  builder_.add_hp(hp);
  builder_.add_pos(pos);
  builder_.add_objectTypeName(objectTypeName);
  builder_.add_objectId(objectId);
  builder_.add_resourceType(resourceType);
  builder_.add_objectType(objectType);
  builder_.add_objectState(objectState);
  builder_.add_objectClass(objectClass);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommonObjectInfo> CreateCommonObjectInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    uint8_t objectClass = 0,
    int16_t objectType = 0,
    const char *objectTypeName = nullptr,
    ObjectState objectState = ObjectState_Ready,
    const Pos *pos = 0,
    float hp = 0.0f,
    float maxHp = 0.0f,
    int16_t resourceType = 0,
    float resourceAmount = 0.0f) {
  return AOC::CreateCommonObjectInfo(
      _fbb,
      objectId,
      objectClass,
      objectType,
      objectTypeName ? _fbb.CreateString(objectTypeName) : 0,
      objectState,
      pos,
      hp,
      maxHp,
      resourceType,
      resourceAmount);
}

struct Building FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMON = 4,
    VT_RESEARCHINGTECHID = 6,
    VT_QUEUE = 8,
    VT_TRAINING = 10
  };
  const CommonObjectInfo *common() const {
    return GetPointer<const CommonObjectInfo *>(VT_COMMON);
  }
  int16_t researchingTechId() const {
    return GetField<int16_t>(VT_RESEARCHINGTECHID, 0);
  }
  const flatbuffers::Vector<const UnitQueue *> *queue() const {
    return GetPointer<const flatbuffers::Vector<const UnitQueue *> *>(VT_QUEUE);
  }
  const UnitTraining *training() const {
    return GetStruct<const UnitTraining *>(VT_TRAINING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyField<int16_t>(verifier, VT_RESEARCHINGTECHID) &&
           VerifyOffset(verifier, VT_QUEUE) &&
           verifier.VerifyVector(queue()) &&
           VerifyField<UnitTraining>(verifier, VT_TRAINING) &&
           verifier.EndTable();
  }
};

struct BuildingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<CommonObjectInfo> common) {
    fbb_.AddOffset(Building::VT_COMMON, common);
  }
  void add_researchingTechId(int16_t researchingTechId) {
    fbb_.AddElement<int16_t>(Building::VT_RESEARCHINGTECHID, researchingTechId, 0);
  }
  void add_queue(flatbuffers::Offset<flatbuffers::Vector<const UnitQueue *>> queue) {
    fbb_.AddOffset(Building::VT_QUEUE, queue);
  }
  void add_training(const UnitTraining *training) {
    fbb_.AddStruct(Building::VT_TRAINING, training);
  }
  explicit BuildingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BuildingBuilder &operator=(const BuildingBuilder &);
  flatbuffers::Offset<Building> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Building>(end);
    return o;
  }
};

inline flatbuffers::Offset<Building> CreateBuilding(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CommonObjectInfo> common = 0,
    int16_t researchingTechId = 0,
    flatbuffers::Offset<flatbuffers::Vector<const UnitQueue *>> queue = 0,
    const UnitTraining *training = 0) {
  BuildingBuilder builder_(_fbb);
  builder_.add_training(training);
  builder_.add_queue(queue);
  builder_.add_common(common);
  builder_.add_researchingTechId(researchingTechId);
  return builder_.Finish();
}

inline flatbuffers::Offset<Building> CreateBuildingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CommonObjectInfo> common = 0,
    int16_t researchingTechId = 0,
    const std::vector<UnitQueue> *queue = nullptr,
    const UnitTraining *training = 0) {
  return AOC::CreateBuilding(
      _fbb,
      common,
      researchingTechId,
      queue ? _fbb.CreateVectorOfStructs<UnitQueue>(*queue) : 0,
      training);
}

struct Unit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMON = 4,
    VT_ACTIONSTATE = 6,
    VT_ACTIONTARGETID = 8,
    VT_ACTIONTARGETPOS = 10
  };
  const CommonObjectInfo *common() const {
    return GetPointer<const CommonObjectInfo *>(VT_COMMON);
  }
  ActionState actionState() const {
    return static_cast<ActionState>(GetField<int8_t>(VT_ACTIONSTATE, 0));
  }
  int32_t actionTargetId() const {
    return GetField<int32_t>(VT_ACTIONTARGETID, 0);
  }
  const Pos *actionTargetPos() const {
    return GetStruct<const Pos *>(VT_ACTIONTARGETPOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyField<int8_t>(verifier, VT_ACTIONSTATE) &&
           VerifyField<int32_t>(verifier, VT_ACTIONTARGETID) &&
           VerifyField<Pos>(verifier, VT_ACTIONTARGETPOS) &&
           verifier.EndTable();
  }
};

struct UnitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<CommonObjectInfo> common) {
    fbb_.AddOffset(Unit::VT_COMMON, common);
  }
  void add_actionState(ActionState actionState) {
    fbb_.AddElement<int8_t>(Unit::VT_ACTIONSTATE, static_cast<int8_t>(actionState), 0);
  }
  void add_actionTargetId(int32_t actionTargetId) {
    fbb_.AddElement<int32_t>(Unit::VT_ACTIONTARGETID, actionTargetId, 0);
  }
  void add_actionTargetPos(const Pos *actionTargetPos) {
    fbb_.AddStruct(Unit::VT_ACTIONTARGETPOS, actionTargetPos);
  }
  explicit UnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitBuilder &operator=(const UnitBuilder &);
  flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unit> CreateUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CommonObjectInfo> common = 0,
    ActionState actionState = ActionState_None,
    int32_t actionTargetId = 0,
    const Pos *actionTargetPos = 0) {
  UnitBuilder builder_(_fbb);
  builder_.add_actionTargetPos(actionTargetPos);
  builder_.add_actionTargetId(actionTargetId);
  builder_.add_common(common);
  builder_.add_actionState(actionState);
  return builder_.Finish();
}

struct MapObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMON = 4
  };
  const CommonObjectInfo *common() const {
    return GetPointer<const CommonObjectInfo *>(VT_COMMON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           verifier.EndTable();
  }
};

struct MapObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<CommonObjectInfo> common) {
    fbb_.AddOffset(MapObject::VT_COMMON, common);
  }
  explicit MapObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapObjectBuilder &operator=(const MapObjectBuilder &);
  flatbuffers::Offset<MapObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapObject>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapObject> CreateMapObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CommonObjectInfo> common = 0) {
  MapObjectBuilder builder_(_fbb);
  builder_.add_common(common);
  return builder_.Finish();
}

inline const AOC::ConfigMessage *GetConfigMessage(const void *buf) {
  return flatbuffers::GetRoot<AOC::ConfigMessage>(buf);
}

inline const AOC::ConfigMessage *GetSizePrefixedConfigMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<AOC::ConfigMessage>(buf);
}

inline bool VerifyConfigMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AOC::ConfigMessage>(nullptr);
}

inline bool VerifySizePrefixedConfigMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AOC::ConfigMessage>(nullptr);
}

inline void FinishConfigMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AOC::ConfigMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedConfigMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AOC::ConfigMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace AOC

#endif  // FLATBUFFERS_GENERATED_CPSCHEMADEF_AOC_H_
